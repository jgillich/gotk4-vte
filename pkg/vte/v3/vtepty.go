// Code generated by girgen. DO NOT EDIT.

package vte

import (
	"context"
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gcancel"
	"github.com/diamondburned/gotk4/pkg/core/gerror"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
	"github.com/diamondburned/gotk4/pkg/gio/v2"
	"github.com/diamondburned/gotk4/pkg/glib/v2"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <vte/vte.h>
import "C"

// GType values.
var (
	GTypePty = coreglib.Type(C.vte_pty_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypePty, F: marshalPty},
	})
}

// SPAWN_NO_PARENT_ENVV: use this as a spawn flag (together with flags from
// Flags) in vte_pty_spawn_async().
//
// Normally, the spawned process inherits the environment from the parent
// process; when this flag is used, only the environment variables passed to
// vte_pty_spawn_async() etc. are passed to the child process.
const SPAWN_NO_PARENT_ENVV = 33554432

// PtyErrorQuark: error domain for VTE PTY errors. Errors in this domain will
// be from the PtyError enumeration. See #GError for more information on error
// domains.
//
// The function returns the following values:
//
//   - quark: error domain for VTE PTY errors.
//
func PtyErrorQuark() glib.Quark {
	var _cret C.GQuark // in

	_cret = C.vte_pty_error_quark()

	var _quark glib.Quark // out

	_quark = uint32(_cret)
	type _ = glib.Quark
	type _ = uint32

	return _quark
}

type Pty struct {
	_ [0]func() // equal guard
	*coreglib.Object

	gio.Initable
}

var (
	_ coreglib.Objector = (*Pty)(nil)
)

func wrapPty(obj *coreglib.Object) *Pty {
	return &Pty{
		Object: obj,
		Initable: gio.Initable{
			Object: obj,
		},
	}
}

func marshalPty(p uintptr) (interface{}, error) {
	return wrapPty(coreglib.ValueFromNative(unsafe.Pointer(p)).Object()), nil
}

// NewPtyForeignSync creates a new Pty for the PTY master fd.
//
// No entry will be made in the lastlog, utmp or wtmp system files.
//
// Note that the newly created Pty will take ownership of fd and close it on
// finalize.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - fd: file descriptor to the PTY.
//
// The function returns the following values:
//
//   - pty: new Pty for fd, or NULL on error with error filled in.
//
func NewPtyForeignSync(ctx context.Context, fd int) (*Pty, error) {
	var _arg2 *C.GCancellable // out
	var _arg1 C.int           // out
	var _cret *C.VtePty       // in
	var _cerr *C.GError       // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.int(fd)

	_cret = C.vte_pty_new_foreign_sync(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(fd)

	var _pty *Pty    // out
	var _goerr error // out

	_pty = wrapPty(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pty, _goerr
}

// NewPtySync allocates a new pseudo-terminal.
//
// You can later use fork() or the g_spawn_async() family of functions to start
// a process on the PTY.
//
// If using fork(), you MUST call vte_pty_child_setup() in the child.
//
// If using g_spawn_async() and friends, you MUST either use
// vte_pty_child_setup() directly as the child setup function, or call
// vte_pty_child_setup() from your own child setup function supplied.
//
// When using vte_terminal_spawn_sync() with a custom child setup function,
// vte_pty_child_setup() will be called before the supplied function; you must
// not call it again.
//
// Also, you MUST pass the G_SPAWN_DO_NOT_REAP_CHILD flag.
//
// Note also that G_SPAWN_STDOUT_TO_DEV_NULL, G_SPAWN_STDERR_TO_DEV_NULL,
// and G_SPAWN_CHILD_INHERITS_STDIN are not supported, since stdin, stdout and
// stderr of the child process will always be connected to the PTY.
//
// Note that you should set the PTY's size using vte_pty_set_size() before
// spawning the child process, so that the child process has the correct size
// from the start instead of starting with a default size and then shortly
// afterwards receiving a <literal>SIGWINCH</literal> signal. You should prefer
// using vte_terminal_pty_new_sync() which does this automatically.
//
// The function takes the following parameters:
//
//   - ctx (optional) or NULL.
//   - flags from PtyFlags.
//
// The function returns the following values:
//
//   - pty: new Pty, or NULL on error with error filled in.
//
func NewPtySync(ctx context.Context, flags PtyFlags) (*Pty, error) {
	var _arg2 *C.GCancellable // out
	var _arg1 C.VtePtyFlags   // out
	var _cret *C.VtePty       // in
	var _cerr *C.GError       // in

	{
		cancellable := gcancel.GCancellableFromContext(ctx)
		defer runtime.KeepAlive(cancellable)
		_arg2 = (*C.GCancellable)(unsafe.Pointer(cancellable.Native()))
	}
	_arg1 = C.VtePtyFlags(flags)

	_cret = C.vte_pty_new_sync(_arg1, _arg2, &_cerr)
	runtime.KeepAlive(ctx)
	runtime.KeepAlive(flags)

	var _pty *Pty    // out
	var _goerr error // out

	_pty = wrapPty(coreglib.AssumeOwnership(unsafe.Pointer(_cret)))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _pty, _goerr
}

func (pty *Pty) ChildSetup() {
	var _arg0 *C.VtePty // out

	_arg0 = (*C.VtePty)(unsafe.Pointer(coreglib.InternObject(pty).Native()))

	C.vte_pty_child_setup(_arg0)
	runtime.KeepAlive(pty)
}

// Close: since 0.42 this is a no-op.
//
// Deprecated: since version 0.42.
func (pty *Pty) Close() {
	var _arg0 *C.VtePty // out

	_arg0 = (*C.VtePty)(unsafe.Pointer(coreglib.InternObject(pty).Native()))

	C.vte_pty_close(_arg0)
	runtime.KeepAlive(pty)
}

// The function returns the following values:
//
//   - gint: file descriptor of the PTY master in pty. The file descriptor
//     belongs to pty and must not be closed or have its flags changed.
//
func (pty *Pty) Fd() int {
	var _arg0 *C.VtePty // out
	var _cret C.int     // in

	_arg0 = (*C.VtePty)(unsafe.Pointer(coreglib.InternObject(pty).Native()))

	_cret = C.vte_pty_get_fd(_arg0)
	runtime.KeepAlive(pty)

	var _gint int // out

	_gint = int(_cret)

	return _gint
}

// Size reads the pseudo terminal's window size.
//
// If getting the window size failed, error will be set to a OError.
//
// The function returns the following values:
//
//   - rows (optional): location to store the number of rows, or NULL.
//   - columns (optional): location to store the number of columns, or NULL.
//
func (pty *Pty) Size() (rows, columns int, goerr error) {
	var _arg0 *C.VtePty // out
	var _arg1 C.int     // in
	var _arg2 C.int     // in
	var _cerr *C.GError // in

	_arg0 = (*C.VtePty)(unsafe.Pointer(coreglib.InternObject(pty).Native()))

	C.vte_pty_get_size(_arg0, &_arg1, &_arg2, &_cerr)
	runtime.KeepAlive(pty)

	var _rows int    // out
	var _columns int // out
	var _goerr error // out

	_rows = int(_arg1)
	_columns = int(_arg2)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _rows, _columns, _goerr
}

// SetSize attempts to resize the pseudo terminal's window size. If successful,
// the OS kernel will send <literal>SIGWINCH</literal> to the child process
// group.
//
// If setting the window size failed, error will be set to a OError.
//
// The function takes the following parameters:
//
//   - rows: desired number of rows.
//   - columns: desired number of columns.
//
func (pty *Pty) SetSize(rows, columns int) error {
	var _arg0 *C.VtePty // out
	var _arg1 C.int     // out
	var _arg2 C.int     // out
	var _cerr *C.GError // in

	_arg0 = (*C.VtePty)(unsafe.Pointer(coreglib.InternObject(pty).Native()))
	_arg1 = C.int(rows)
	_arg2 = C.int(columns)

	C.vte_pty_set_size(_arg0, _arg1, _arg2, &_cerr)
	runtime.KeepAlive(pty)
	runtime.KeepAlive(rows)
	runtime.KeepAlive(columns)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// SetUTF8 tells the kernel whether the terminal is UTF-8 or not, in case it
// can make use of the info. Linux 2.6.5 or so defines IUTF8 to make the line
// discipline do multibyte backspace correctly.
//
// The function takes the following parameters:
//
//   - utf8: whether or not the pty is in UTF-8 mode.
//
func (pty *Pty) SetUTF8(utf8 bool) error {
	var _arg0 *C.VtePty  // out
	var _arg1 C.gboolean // out
	var _cerr *C.GError  // in

	_arg0 = (*C.VtePty)(unsafe.Pointer(coreglib.InternObject(pty).Native()))
	if utf8 {
		_arg1 = C.TRUE
	}

	C.vte_pty_set_utf8(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(pty)
	runtime.KeepAlive(utf8)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}
