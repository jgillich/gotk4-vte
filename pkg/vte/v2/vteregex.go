// Code generated by girgen. DO NOT EDIT.

package vte

import (
	"runtime"
	"unsafe"

	"github.com/diamondburned/gotk4/pkg/core/gerror"
	"github.com/diamondburned/gotk4/pkg/core/gextras"
	coreglib "github.com/diamondburned/gotk4/pkg/core/glib"
)

// #include <stdlib.h>
// #include <glib-object.h>
// #include <vte/vte.h>
import "C"

// GType values.
var (
	GTypeRegex = coreglib.Type(C.vte_regex_get_type())
)

func init() {
	coreglib.RegisterGValueMarshalers([]coreglib.TypeMarshaler{
		coreglib.TypeMarshaler{T: GTypeRegex, F: marshalRegex},
	})
}

const REGEX_FLAGS_DEFAULT = 1075314688

// Regex: instance of this type is always passed by reference.
type Regex struct {
	*regex
}

// regex is the struct that's finalized.
type regex struct {
	native *C.VteRegex
}

func marshalRegex(p uintptr) (interface{}, error) {
	b := coreglib.ValueFromNative(unsafe.Pointer(p)).Boxed()
	return &Regex{&regex{(*C.VteRegex)(b)}}, nil
}

// NewRegexForMatch constructs a struct Regex.
func NewRegexForMatch(pattern string, patternLength int, flags uint32) (*Regex, error) {
	var _arg1 *C.char     // out
	var _arg2 C.gssize    // out
	var _arg3 C.guint32   // out
	var _cret *C.VteRegex // in
	var _cerr *C.GError   // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(patternLength)
	_arg3 = C.guint32(flags)

	_cret = C.vte_regex_new_for_match(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(patternLength)
	runtime.KeepAlive(flags)

	var _regex *Regex // out
	var _goerr error  // out

	_regex = (*Regex)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_regex)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.vte_regex_unref((*C.VteRegex)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _regex, _goerr
}

// NewRegexForSearch constructs a struct Regex.
func NewRegexForSearch(pattern string, patternLength int, flags uint32) (*Regex, error) {
	var _arg1 *C.char     // out
	var _arg2 C.gssize    // out
	var _arg3 C.guint32   // out
	var _cret *C.VteRegex // in
	var _cerr *C.GError   // in

	_arg1 = (*C.char)(unsafe.Pointer(C.CString(pattern)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = C.gssize(patternLength)
	_arg3 = C.guint32(flags)

	_cret = C.vte_regex_new_for_search(_arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(pattern)
	runtime.KeepAlive(patternLength)
	runtime.KeepAlive(flags)

	var _regex *Regex // out
	var _goerr error  // out

	_regex = (*Regex)(gextras.NewStructNative(unsafe.Pointer(_cret)))
	runtime.SetFinalizer(
		gextras.StructIntern(unsafe.Pointer(_regex)),
		func(intern *struct{ C unsafe.Pointer }) {
			C.vte_regex_unref((*C.VteRegex)(intern.C))
		},
	)
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _regex, _goerr
}

// Jit: if the platform supports JITing, JIT compiles regex.
//
// The function takes the following parameters:
//
//   - flags: PCRE2 JIT flags, or 0.
//
func (regex *Regex) Jit(flags uint32) error {
	var _arg0 *C.VteRegex // out
	var _arg1 C.guint32   // out
	var _cerr *C.GError   // in

	_arg0 = (*C.VteRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = C.guint32(flags)

	C.vte_regex_jit(_arg0, _arg1, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(flags)

	var _goerr error // out

	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _goerr
}

// Substitute: see man:pcre2api(3) and man:pcre2_substitute(3) for more
// information.
//
// The function takes the following parameters:
//
//   - subject string.
//   - replacement string.
//   - flags: PCRE2 match flags.
//
// The function returns the following values:
//
//   - utf8: substituted string, or NULL if an error occurred.
//
func (regex *Regex) Substitute(subject string, replacement string, flags uint32) (string, error) {
	var _arg0 *C.VteRegex // out
	var _arg1 *C.char     // out
	var _arg2 *C.char     // out
	var _arg3 C.guint32   // out
	var _cret *C.char     // in
	var _cerr *C.GError   // in

	_arg0 = (*C.VteRegex)(gextras.StructNative(unsafe.Pointer(regex)))
	_arg1 = (*C.char)(unsafe.Pointer(C.CString(subject)))
	defer C.free(unsafe.Pointer(_arg1))
	_arg2 = (*C.char)(unsafe.Pointer(C.CString(replacement)))
	defer C.free(unsafe.Pointer(_arg2))
	_arg3 = C.guint32(flags)

	_cret = C.vte_regex_substitute(_arg0, _arg1, _arg2, _arg3, &_cerr)
	runtime.KeepAlive(regex)
	runtime.KeepAlive(subject)
	runtime.KeepAlive(replacement)
	runtime.KeepAlive(flags)

	var _utf8 string // out
	var _goerr error // out

	_utf8 = C.GoString((*C.gchar)(unsafe.Pointer(_cret)))
	defer C.free(unsafe.Pointer(_cret))
	if _cerr != nil {
		_goerr = gerror.Take(unsafe.Pointer(_cerr))
	}

	return _utf8, _goerr
}
